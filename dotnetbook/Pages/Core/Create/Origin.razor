@page "/create/origin"

<PageTitle>Основы типов - .NET книга</PageTitle>

<div class="border-1 bg-light shadow rounded-1 p-2">

    <h1>Основы типов</h1>
    <hr />
    <NavLink href="core" class="link-success">
        Руководство .NET
    </NavLink>
    <hr />
    <h4>Инкапсуляция</h4>
    <p>Такая характерная черта как инкапсуляция описывает способность языка скрывать излишние детали реализации от
        пользователя объекта.</p>
    <p>Модификаторы доступа по всему C#:</p>
    <table class="table">
        <thead>
            <tr>
                <th scope="col">Модификатор доступа</th>
                <th scope="col">Может быть применен</th>
                <th scope="col">Практический смысл</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <th scope="row">public</th>
                <td>Типы или члены типов</td>
                <td>Открытые члены доступны из любого объекта, производного класса, другой сборки</td>
            </tr>
            <tr>
                <th scope="row">private</th>
                <td>Члены типов или вложенные типы</td>
                <td>Доступны только классу, где определены</td>
            </tr>
            <tr>
                <th scope="row">protected</th>
                <td>Члены типов или вложенные типы</td>
                <td>Доступны классу, где определены и любым дочерним классам</td>
            </tr>
            <tr>
                <th scope="row">internal</th>
                <td>Типы и члены типов</td>
                <td>Доступны только внутри сборки</td>
            </tr>
            <tr>
                <th scope="row">protected internal</th>
                <td>Члены типов или вложенные типы</td>
                <td>Доступен внутри сборки, внутри класса и производным классам внутри или вне сборки</td>
            </tr>
            <tr>
                <th scope="row">private protected</th>
                <td>Члены типов или вложенные типы</td>
                <td>Доступен внутри класса и производным классам внутри сборки</td>
            </tr>
        </tbody>
    </table>


    <h4>Наследование</h4>
    <p>Наследование — это аспект ООП, упрощающий повторное использование кода.</p>
    <p>Все типы прямо или косвенно являются производными от System.Object. Все значимые типы наследуются от ValueType, а
        ValueType в свою очередь - от System.Object.</p>
    <p>У класса System.Object есть следующие открытые экземплярные методы:</p>
    <p>Equals() - сравнение двух объектов на равенство</p>
    <p>GetHashCode() - возвращает хеш-код значения данного объекта</p>
    <p>ToString() - возвращает полное имя типа, в некоторых типах переопределен</p>
    <p>GetType() - невиртуальный метод возвращает экземпляр объекта, производнго от Type</p>
    <p>Защищенные методы:</p>
    <p>MemberwiseClone() - невиртуальный метод создает новый экземпляр типа и присваивает полям нового объекта
        соответствующие значения объекта this</p>
    <p>Finalize() - Вызывается, когда уборщик мусора определяет, что объект является мусором, но до возвращения занятой
        объектом памяти в кучу</p>
    <p>Любой производный от Object класс наследует сигнатуры методов и реализацию этих методов. Только один класс может
        быть базовым для другого класса.</p>

    <div class="border border-dark rounded-1 px-2 my-2">
        <pre class="my-3">
var h = 12.GetHashCode();
var b = 12.Equals(23);
var s = 12.ToString();
var t = 12.GetType();</pre>
    </div>

    <p>Определение System.Object:</p>

    <div class="border border-dark rounded-1 px-2 my-2">
        <pre class="my-3">
public class Object
{
    // Виртуальные члены.
    public virtual bool Equals(object obj);
    protected virtual void Finalize();
    public virtual int GetHashCode();
    public virtual string ToString();
    // Невиртуальные члены уровня экземпляра.
    public Type GetType();
    protected object MemberwiseClone();
    // Статические члены.
    public static bool Equals(object objA, object objB);
    public static bool ReferenceEquals(object objA, object objB);
}</pre>
    </div>

    <h4>Создание типа</h4>
    <p>Все объекты ссылочных типов по требованию CLR должны создаваться оператором new. Допустимо для нового значения
        применять вместо new литерал default. Можно использовать оператор new при создании примитивных типов. Можно не
        использовать имя типа после new при указании типа объека.</p>
    <div class="border border-dark rounded-1 px-2 my-2">
        <pre class="my-3">
bool bl = true, Ь2 = false, ЬЗ = bl;
Employee e = new Employee();
Employee e = new ();
int myInt = 0;
int i = new int();
int i = new();</pre>
    </div>
    <p>Оператор new выполняет следующие действия:</p>
    <ol class="list-group list-group-numbered">
        <li class="list-group-item">Вычисление количества байтов, необходимых для хранения всех экземплярных полей типа
            и всех его базовых типов, в том числе System.Object. В каждый объект кучи дополнительно: указатель на
            объект-тип и индекс блока синхронизации.</li>
        <li class="list-group-item">Выделение памяти для объекта с резервированием байтов в управляемой куче,
            инициализируются нулями (0).</li>
        <li class="list-group-item">Инициализация указателя на объект-тип и индекса блока синхронизации.</li>
        <li class="list-group-item">Вызов конструктора экземпляра типа с параметрами.</li>
    </ol>
    <p>После этого он возвращает ссылку на вновь созданный объект. Ставшие ненужными или недоступными объекты сборщик
        мусора среды CLR автоматически находит и освобождает.</p>
    <p>Литерал default позволяет присваивать переменной стандартное значение ее типа данных. Литерал default работает
        для стандартных типов данных, а также для специальных классов и обобщенных типов.</p>
    <div class="border border-dark rounded-1 px-2 my-2">
        <pre class="my-3">
int myInt = default;
var myInt = default(int);</pre>
    </div>
    <p>Все примитивные типы данных поддерживают стандартный конструктор, можно создать переменную, используя ключевое
        слово new():</p>
    <div class="border border-dark rounded-1 px-2 my-2">
        <pre class="my-3">
bool b = new bool(); // false
b = new(); // false
int i = new int(); // 0
i = new(); // 0
char c = new char(); // ' '
c = new(); // ' '
double d = new double(); // 0.0
d = new(); // 0.0
DateTime dt = new DateTime(); // 1/1/0001 12:00:00 AM
dt = new(); // 1/1/0001 12:00:00 AM</pre>
    </div>
    <p>Все числовые типы .NET Core поддерживают разнообразные свойства: MaxValue и MinValue и другие полезные члены.</p>
    <p>В C# можно вот так объявлять экземпляр используемой структуры с использованием выражения with:</p>
    <div class="border border-dark rounded-1 px-2 my-2">
        <pre class="my-3">
var v2 = new SampleVal() with { Val2 = 20 };</pre>
    </div>

    <h4>Ленивое создание объектов</h4>
    <p>Когда объект или переменная в программе может и не понадобится вовсе можно применять обобщенный класс
        Lazy<code>&lt;&gt;</code>.
        Этот класс позволяет определять данные, которые не будут создаваться до тех пор, пока действительно не будут
        применяться в коде.</p>
    <p>Пример:</p>
    <div class="border border-dark rounded-1 px-2 my-2">
        <pre class="my-3">
public class Sample : IEnumerable
{
    private int[] arr;
    public Sample()
    {
        arr = Enumerable.Range(1, 100).Select(x => x).ToArray();
    }
    IEnumerator IEnumerable.GetEnumerator()
    {
        foreach (var e in arr)
            yield return e;
    }
}
//использование
var sample = new Lazy&lt;Sample&gt;();<code>&lt;section&gt;</code>
foreach (var e in sample.Value)
{
    Console.Write("{0} ", e);
}</pre>
    </div>
    <p>Ленивое создание объектов полезно не только для уменьшения количества выделений памяти под ненужные объекты. Этот
        прием можно также использовать в ситуации, когда для создания члена применяется затратный в плане ресурсов код,
        такой как вызов удаленного метода, взаимодействие с реляционной базой данных и т.п.</p>
    <p>Класс Lazy<code>&lt;&gt;</code>() позволяет указывать в качестве необязательного параметра обобщенный делегат,
        который задает метод для вызова во время создания находящегося внутри типа. Этот метод должен возвращать новый
        объект требуемого типа.</p>
    <div class="border border-dark rounded-1 px-2 my-2">
        <pre class="my-3">
var sample = new Lazy&lt;Sample&gt;(() => 
{
    return new Sample();
});</pre>
    </div>

    <hr />
    <div class="text-center">
        <NavLink href="core" class="link-success">
            Содержание
        </NavLink>
    </div>

</div>
