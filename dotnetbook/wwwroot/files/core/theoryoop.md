# ООП

Все объектно-ориентированне языки должны поддерживать три основных принципа ООП:

- Инкапсуляция. Сокрытие деталей внутренней реализации объектов.

- Наследование. Многократное повторное использования кода.

- Полиморфизм. Трактовка связанных объектов в сходной манере.

- Композиция. Включение одного класса в другой.

## Инкапсуляция.

Это способность языка скрывать излишние детали реализации от пользователя объекта. Класс скрывает внутренние детали оперирования с данными, этот принцип ООП упрощает задачи кодирования. Код, работающий за кулисами может быть свободно изменен, извне его никто не видит.

С этим понятием связана идея защита данных. В идеале все поля данных должны быть с ключевым словом private и protected. И в итоге внешний код должен обращатся к этим полям аккуратно, через открытые члены, в то время как открытые поля данных могут быть свободно изменены и это приведет к повреждению данных объекта.

```csharp
MyClass obj = new MyClass();
obj.Open();
obj.Close();
```

## Наследование.

Этот принцип языка отражает возможность языка разрешать построение определений новых классов на основе кода существующих. Это позволяет расширять поведение базового класса за счет наследования его основной функциональности производным классом.

Описание классов: класс Кошка является Питомцем, которая является объектом. Между ними устанавливается отношение явлется (is a). Это и есть наследование.

Класс питомцев определяет небольшое количество членов, общих для всех питомцев. Класс кошка наследует основную функциональность, определяемую классами питомцев и объекта, вдобавок к этому сам определяет дополнительные детали, характерные для кошек.

```csharp
public class Pet
{ }
public class Cat : Pet
{ }
```

## Полиморфизм

Еще один принцип ООП - полиморфизм, это черта обозначает способность языка трактовать связанные объекты в сходной манере. Базовый класс может определеять набор членов, которые доступны всем наследникам. Этот полиморфный интерфейс конструируется с применением любого количества виртуальных или абстрактных членов.

Виртуальный член - член базового класса, реализацию которого можно изменять в производном классе.

Абстрактный член - член базового класса, который предоставляет только сигнатуру, но не реализацию.

Абстрактный член обязательно должен быть переопределен в производном классе.

Пример: так как и кошка и собака унаследованы от класса питомцы, они имеют разную реализацию метода подачи голоса. Кошка - мяукает, а собака - гавкает.

Пример классов:

```csharp
public class Pet
{
    virtual public void Print()
    { }
}
public class Cat : Pet
{
    public override void Print()
    {
        WriteLine("Мяу");
    }
}

public class Dog : Pet
{
    public override void Print()
    {
        WriteLine("Гав");
    }
}
```
Использование:
```csharp
Pet pet1 = new Cat();
Pet pet2 = new Dog();
pet1.Print(); //мяу
pet2.Print(); //гав
```

## Композиция

Еще одна форма повторного использования кода - включения/делегации называемая имеет (has a) или агрегация. Отношение имеет позволяет одному классу определять переменную-член другого класса и открывать доступ к его функциональности пользователю объекта. 

Пример - класс кошка имеет хвост и скрывает к нему доступ:

```csharp
public class Cat
{
    private Tail tail = new Tail();
    private class Tail
    { }
}
```

